<!doctype html><html lang=en-us>
<head>
<link rel=preload href=/lib/font-awesome/webfonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin=anonymous>
<link rel=preload href=/lib/font-awesome/webfonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin=anonymous>
<link rel=preload href=/lib/font-awesome/webfonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin=anonymous>
<link rel=preload href=/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous>
<script type=text/javascript src=https://latest.cactus.chat/cactus.js></script>
<link rel=stylesheet href=https://latest.cactus.chat/style.css type=text/css>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<title> Gradual Typing in Adelfa | Chase Johnson</title>
<link rel=canonical href=https://chasejohnson.tech/posts/gradual-typing-adelfa/>
<meta name=description content="Welcome to my blog! I'm a Computer Science MS student at the University of Minnesota with a particular interest in programming languages.">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=robots content="all,follow">
<meta name=googlebot content="index,follow,snippet,archive">
<meta property="og:title" content="Gradual Typing in Adelfa">
<meta property="og:description" content="Introduction   Gradual Typing is a type system that marries static and dynamic typing. It was developed in 2006 by Jeremy Siek and Walid Taha. Dynamic type systems offer complete flexibility and agility; whereas static typing offers type-related error detection earlier. Gradual typing allows us to declare types as dynamic and also specify types. Moreover, we can coerce types to and from dynamic throughout its execution.
 I won't be going over Gradual Typing too closely, because Professor Siek has his very own excellent blog you should give a read if you're interested.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://chasejohnson.tech/posts/gradual-typing-adelfa/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-01-01T13:25:08-06:00">
<meta property="article:modified_time" content="2022-01-01T13:25:08-06:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Gradual Typing in Adelfa">
<meta name=twitter:description content="Introduction   Gradual Typing is a type system that marries static and dynamic typing. It was developed in 2006 by Jeremy Siek and Walid Taha. Dynamic type systems offer complete flexibility and agility; whereas static typing offers type-related error detection earlier. Gradual typing allows us to declare types as dynamic and also specify types. Moreover, we can coerce types to and from dynamic throughout its execution.
 I won't be going over Gradual Typing too closely, because Professor Siek has his very own excellent blog you should give a read if you're interested.">
<link rel=stylesheet href=https://chasejohnson.tech/css/styles.94f653e9e151e28067a7c5dbbc4600cbd5a3c721e79faaf971e523c40f3b249b8e4f20bb57810dfffa8d559ca5c140fd56eb4cd9c0853113ad08e66afdb08bdd.css integrity="sha512-lPZT6eFR4oBnp8XbvEYAy9WjxyHnn6r5ceUjxA87JJuOTyC7V4EN//qNVZylwUD9VutM2cCFMROtCOZq/bCL3Q=="><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script>
<script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]-->
</head>
<body class="max-width mx-auto px3 ltr">
<div class="content index py4">
<div id=header-post>
<a id=menu-icon href=#><i class="fas fa-bars fa-lg"></i></a>
<a id=menu-icon-tablet href=#><i class="fas fa-bars fa-lg"></i></a>
<a id=top-icon-tablet href=# onclick="$('html, body').animate({scrollTop:0},'fast')" style=display:none aria-label="Top of Page"><i class="fas fa-chevron-up fa-lg"></i></a>
<span id=menu>
<span id=nav>
<ul>
<li><a href=/>Home</a></li>
<li><a href=/posts>All Posts</a></li>
<li><a href=/about>About</a></li>
</ul>
</span>
<br>
<span id=actions>
<ul>
<li>
<a class=icon href=https://chasejohnson.tech/about/ aria-label=Previous>
<i class="fas fa-chevron-left" aria-hidden=true onmouseover="$('#i-prev').toggle()" onmouseout="$('#i-prev').toggle()"></i>
</a>
</li>
<li>
<a class=icon href=# onclick="$('html, body').animate({scrollTop:0},'fast')" aria-label="Top of Page">
<i class="fas fa-chevron-up" aria-hidden=true onmouseover="$('#i-top').toggle()" onmouseout="$('#i-top').toggle()"></i>
</a>
</li>
<li>
<a class=icon href=# aria-label=Share>
<i class="fas fa-share-alt" aria-hidden=true onmouseover="$('#i-share').toggle()" onmouseout="$('#i-share').toggle()" onclick="return $('#share').toggle(),!1"></i>
</a>
</li>
</ul>
<span id=i-prev class=info style=display:none>Previous post</span>
<span id=i-next class=info style=display:none>Next post</span>
<span id=i-top class=info style=display:none>Back to top</span>
<span id=i-share class=info style=display:none>Share post</span>
</span>
<br>
<div id=share style=display:none>
<ul>
<li>
<a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fchasejohnson.tech%2fposts%2fgradual-typing-adelfa%2f" aria-label=Facebook>
<i class="fab fa-facebook" aria-hidden=true></i>
</a>
</li>
<li>
<a class=icon href="https://twitter.com/share?url=https%3a%2f%2fchasejohnson.tech%2fposts%2fgradual-typing-adelfa%2f&text=Gradual%20Typing%20in%20Adelfa" aria-label=Twitter>
<i class="fab fa-twitter" aria-hidden=true></i>
</a>
</li>
<li>
<a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fchasejohnson.tech%2fposts%2fgradual-typing-adelfa%2f&title=Gradual%20Typing%20in%20Adelfa" aria-label=Linkedin>
<i class="fab fa-linkedin" aria-hidden=true></i>
</a>
</li>
<li>
<a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fchasejohnson.tech%2fposts%2fgradual-typing-adelfa%2f&is_video=false&description=Gradual%20Typing%20in%20Adelfa" aria-label=Pinterest>
<i class="fab fa-pinterest" aria-hidden=true></i>
</a>
</li>
<li>
<a class=icon href="mailto:?subject=Gradual%20Typing%20in%20Adelfa&body=Check out this article: https%3a%2f%2fchasejohnson.tech%2fposts%2fgradual-typing-adelfa%2f" aria-label=Email>
<i class="fas fa-envelope" aria-hidden=true></i>
</a>
</li>
<li>
<a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fchasejohnson.tech%2fposts%2fgradual-typing-adelfa%2f&title=Gradual%20Typing%20in%20Adelfa" aria-label=Pocket>
<i class="fab fa-get-pocket" aria-hidden=true></i>
</a>
</li>
<li>
<a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fchasejohnson.tech%2fposts%2fgradual-typing-adelfa%2f&title=Gradual%20Typing%20in%20Adelfa" aria-label=reddit>
<i class="fab fa-reddit" aria-hidden=true></i>
</a>
</li>
<li>
<a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fchasejohnson.tech%2fposts%2fgradual-typing-adelfa%2f&name=Gradual%20Typing%20in%20Adelfa&description=Introduction%20%20%20Gradual%20Typing%20is%20a%20type%20system%20that%20marries%20static%20and%20dynamic%20typing.%20It%20was%20developed%20in%202006%20by%20Jeremy%20Siek%20and%20Walid%20Taha.%20Dynamic%20type%20systems%20offer%20complete%20flexibility%20and%20agility%3b%20whereas%20static%20typing%20offers%20type-related%20error%20detection%20earlier.%20Gradual%20typing%20allows%20us%20to%20declare%20types%20as%20dynamic%20and%20also%20specify%20types.%20Moreover%2c%20we%20can%20coerce%20types%20to%20and%20from%20dynamic%20throughout%20its%20execution.%0a%20I%20won%26%2339%3bt%20be%20going%20over%20Gradual%20Typing%20too%20closely%2c%20because%20Professor%20Siek%20has%20his%20very%20own%20excellent%20blog%20you%20should%20give%20a%20read%20if%20you%26%2339%3bre%20interested." aria-label=Tumblr>
<i class="fab fa-tumblr" aria-hidden=true></i>
</a>
</li>
<li>
<a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fchasejohnson.tech%2fposts%2fgradual-typing-adelfa%2f&t=Gradual%20Typing%20in%20Adelfa" aria-label="Hacker News">
<i class="fab fa-hacker-news" aria-hidden=true></i>
</a>
</li>
</ul>
</div>
</span>
</div>
<article class=post itemscope itemtype=http://schema.org/BlogPosting>
<header>
<h1 class=posttitle itemprop="name headline">
Gradual Typing in Adelfa
</h1>
<div class=meta>
<div class=postdate>
<time datetime="2022-01-01 13:25:08 -0600 -0600" itemprop=datePublished>2022-01-01</time>
</div>
<div class=article-read-time>
<i class="far fa-clock"></i>
12 minute read
</div>
</div>
</header>
<div id=toc>
<nav id=TableOfContents>
<ul>
<li><a href=#headline-1>Introduction</a>
</li>
<li><a href=#headline-2>Syntax of The Language</a>
</li>
<li><a href=#headline-3>Type Consistency</a>
<ul>
<li><a href=#headline-4>Symmetry</a>
</li>
<li><a href=#headline-5>Commutativity</a>
</li>
<li><a href=#headline-6>Non-transitivity</a>
</li>
</ul>
</li>
<li><a href=#headline-7>Typing Relations</a>
<ul>
<li><a href=#headline-8>Context Lemmas & Type Equality</a>
</li>
</ul>
</li>
<li><a href=#headline-9>Type Uniqueness</a>
</li>
<li><a href=#headline-10>Preservation</a>
</li>
<li><a href=#headline-11>Progress</a>
</li>
</ul>
</nav>
</div>
<div class=content itemprop=articleBody>
<div id=outline-container-headline-1 class=outline-2>
<h2 id=headline-1>
Introduction
</h2>
<div id=outline-text-headline-1 class=outline-text-2>
<p>
<a href=https://en.wikipedia.org/wiki/Gradual_typing>Gradual Typing</a> is a type system that marries static and dynamic typing. It was
developed in 2006 by <a href=https://wphomes.soic.indiana.edu/jsiek/>Jeremy Siek</a> and <a href=http://www.effective-modeling.org/p/walid-taha.html>Walid Taha</a>. Dynamic type systems offer
complete flexibility and agility; whereas static typing offers type-related
error detection earlier. Gradual typing allows us to declare types as <code>dynamic</code>
and also specify types. Moreover, we can coerce types to and from <code>dynamic</code>
throughout its execution.</p>
<p>
I won't be going over Gradual Typing too closely, because Professor Siek has <a href=https://siek.blogspot.com/>his
very own excellent blog</a> you should give a read if you're interested. This blog
post will focus more on mechanizing some properties of gradual typing in <a href=http://sparrow.cs.umn.edu/adelfa/index.html>Adelfa</a>,
a system I'm currently using as a graduate student. I plan showing more about
Adelfa in a later post, so I'll just be showing a general thought process
involved in the construction of these theorems. I'll focus on <a href=http://scheme2006.cs.uchicago.edu/13-siek.pdf>Gradual Typing for
Functional Languages</a> for this post.</p>
</div>
</div>
<div id=outline-container-headline-2 class=outline-2>
<h2 id=headline-2>
Syntax of The Language
</h2>
<div id=outline-text-headline-2 class=outline-text-2>
<p>
We elide variables, ground types, constants, etc since they are not of interest
in any theorems we will mechanize. The paper describes the syntax of \(e \in
\lambda^{?}_{\rightarrow}\) in section 1. I'll show the paper's description as
one column and the formulation in Adelfa in the other.</p>
<table>
<thead>
<tr>
<th></th>
<th>Gradual Typing Syntax</th>
<th>Adelfa Signature</th>
</tr>
</thead>
<tbody>
<tr>
<td>Type</td>
<td>\(\tau\)</td>
<td><code>ty : type.</code></td>
</tr>
<tr>
<td>Function Type</td>
<td>\(\tau \rightarrow \tau\)</td>
<td><code>arr: {t1: ty}{t2:ty} ty.</code></td>
</tr>
<tr>
<td>Expressions</td>
<td>\(e\)</td>
<td><code>tm : type.</code></td>
</tr>
<tr>
<td>Application</td>
<td>\(e \cdot e\)</td>
<td><code>app: {tm1: tm}{tm2: tm} tm.</code></td>
</tr>
<tr>
<td>Abstraction</td>
<td>\(\lambda x:\tau . e\)</td>
<td><code>lam: {ty1:ty}{D: {x:tm} tm} tm.</code></td>
</tr>
</tbody>
</table>
<p>
We also define a few extra items in Adelfa:</p>
<ul>
<li>
<p><code>unit</code> and <code>nat</code>, essentially placeholders to represent more meaningful types in
an actual system.</p>
</li>
<li>
<p><code>dyn</code> which will represent the \(?\) / \(\star\) type, standing for dynamic.</p>
</li>
<li>
<p><code>empty</code> and <code>z</code> which will be a terms we can use of type <code>unit</code> and <code>nat</code> respectively.</p>
</li>
</ul>
<p>We could use this and then define a system to insert the casts like in the
paper, but I'll only be dealing with the intermediate language of
\(\lambda^{\langle \tau \rangle}_{\rightarrow}\) for simplicity. Therefore,
we'll define the cast as well. In the paper this is written as \(\langle \tau
\rangle e\) where we are casting \(e\) to the target type \(\tau\).</p>
<p>
Here is the Adelfa section in its entirety:</p>
<div class="src src-text">
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>tm : type.
ty : type.
arr : {ty1: ty}{ty2:ty} ty.
lam : {ty1: ty}{D: {x:tm} tm} tm.
app : {t1: tm}{t2: tm} tm.
cast : {ty1: ty}{t1: tm} tm.

unit : ty.
dyn : ty.
nat : ty.
empty : tm.
z : tm.</code></pre></div>
</div>
</div>
</div>
<div id=outline-container-headline-3 class=outline-2>
<h2 id=headline-3>
Type Consistency
</h2>
<div id=outline-text-headline-3 class=outline-text-2>
<p>
For a cast to occur between types, the types must be consistent. Consistency is
shown through a \(\sim\), so \(\tau_{1} \sim \tau_{2}\) is a relation accepting
two types. Here are all the rules for consistency as given in the paper:</p>
<ul>
<li>
<p>CRefl
\begin{equation}
\tau \sim \tau
\end{equation}</p>
</li>
<li>
<p>CUnr
\begin{equation}\label{cunr}
\tau \sim ?
\end{equation}</p>
</li>
<li>
<p>CUnl
\begin{equation}\label{cunl}
? \sim \tau
\end{equation}</p>
</li>
<li>
<p>CFun
\begin{equation}\label{cfun}
\frac{
\sigma_{1} \sim \tau_{1} \quad \sigma_{2} \sim \tau_{2}
}{
\sigma_{1} \rightarrow \sigma_{2} \sim \tau_{1} \rightarrow \tau_{2}
}
\end{equation}</p>
</li>
</ul>
<p>
These can be encoded into Adelfa by first defining a consistency relation that
accepts two types, then we will define each rule based on the input types. Any
conditions that need to be met by the rule can be realized through some
derivation as seen in the <code>consis-fun</code> rule.</p>
<div class="src src-text">
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>consis : {ty1: ty} {ty2: ty} type.
consis-refl: {ty1 : ty} consis ty1 ty1.
consis-dyn-r : {ty1 : ty} consis ty1 dyn.
consis-dyn-l : {ty1 : ty} consis dyn ty1.
consis-fun : {sigma1 : ty}{sigma2 : ty}
             {tau1 : ty}{tau2 : ty}
             {D1: consis sig1 tau1}
             {D2: consis sig2 tau2}
             consis (arr sig1 sig2) (arr tau1 tau2).</code></pre></div>
</div>
<p>
Now that we have the LF signature finished for the consistency relation, we can
prove properties about it. Let's prove all the points mentioned in
Proposition 1.</p>
<ul>
<li>
<p>\(\tau \sim \tau\): the relation is symmetric</p>
</li>
<li>
<p>If \(\sigma \sim \tau\) then \(\tau \sim \sigma\): the relation is commutative.</p>
</li>
<li>
<p>\(\neg (\forall \tau_{1} \tau_{2} \tau_{3} . \tau_{1} \sim \tau_{2} \land
\tau_{2} \sim \tau_{3} \longrightarrow \tau_{1} \sim \tau_{3})\): the relation
is <em>not</em> transitive.</p>
</li>
</ul>
<div id=outline-container-headline-4 class=outline-3>
<h3 id=headline-4>
Symmetry
</h3>
<div id=outline-text-headline-4 class=outline-text-3>
<p>
This arises very naturally from our <code>consis-refl</code> rule. So naturally that to prove
it is essentially unnecessary. Nevertheless, here is the proof.</p>
<div class="src src-text">
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>Theorem consis-symm : forall t1,
  {t1: ty} =&gt;
  exists D1, {D1: consis t1 t1}.
intros.
exists consis-refl t1. search.</code></pre></div>
</div>
</div>
</div>
<div id=outline-container-headline-5 class=outline-3>
<h3 id=headline-5>
Commutativity
</h3>
<div id=outline-text-headline-5 class=outline-text-3>
<p>
The only tricky aspect of this proof is applying the inductive hypothesis in the
case that it is a function type. The other cases are commutative by the \(?\)
being on one side or having the same type on both.</p>
<div class="src src-text">
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>Theorem consis-comm : forall t1 t2 D1,
  {D1: consis t1 t2} =&gt;
  exists D2, {D2: consis t2 t1}.
induction on 1.
intros.
case H1.
apply IH to H6.
apply IH to H7.
exists consis-fun tau1 tau2 sig1 sig2 D2 D1. search.
exists consis-dyn-l t1. search.
exists consis-dyn-r t2. search.
exists consis-refl t2. search.</code></pre></div>
</div>
</div>
</div>
<div id=outline-container-headline-6 class=outline-3>
<h3 id=headline-6>
Non-transitivity
</h3>
<div id=outline-text-headline-6 class=outline-text-3>
<p>
We don't have the not (\(\neg\)) operator, but that's not a problem. We can prove that it
doesn't hold in every case by posing an existential that would lead to a false
assertion. Therefore, we'll formulate the following:</p>
<p>
\begin{equation}
\exists \tau_{1} \tau_2 \tau_3 . \tau_1 \sim \tau_2 \land \tau_2 \sim \tau_3 \implies \tau_1 \sim \tau_3 \implies \bot
\end{equation}</p>
<p>
The transitivity in consistency doesn't work in the case that \(\tau_{2}\) is
\(?\) and \(\tau_1 \not\equiv \tau_3\). Hence, why we cannot prove this with
only <code>unit</code> type.</p>
<div class="src src-text">
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>Theorem consis-not-trans : exists t1 t2 t3,
  {t1: ty} =&gt; {t2: ty} =&gt; {t3: ty} =&gt;
  forall D1 D2 D3,
  {D1: consis t1 t2} /\ {D2: consis t2 t3} =&gt;
  {D3: consis t1 t3} =&gt; false.
exists unit.
exists dyn.
exists nat.
intros.
case H5.</code></pre></div>
</div>
<p>
This gives the case of \(() \sim ?\) and \(? \sim \mathbb{N}\), and clearly \(()
\not \sim \mathbb{N}\), so case analysis will yield \(\bot\).</p>
</div>
</div>
</div>
</div>
<div id=outline-container-headline-7 class=outline-2>
<h2 id=headline-7>
Typing Relations
</h2>
<div id=outline-text-headline-7 class=outline-text-2>
<p>
We'll translate Figure 6's typing derivations for \(\lambda^{\langle \tau
\rangle}_{\rightarrow}\) into Adelfa piece by piece. Just as before, we'll place
any preconditions of the relation into some derivation necessary for the
relation to hold.</p>
<ul>
<li>
<p>Type System
\begin{equation}
\Gamma \vert \Sigma \vdash e : \tau
\end{equation}</p>
<div class="src src-text">
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>of : {t1: tm}{ty1 : ty} type.</code></pre></div>
</div>
</li>
<li>
<p>TLam
\begin{equation}
\frac{
\Gamma (x \mapsto \sigma) \vert \Sigma \vdash e : \tau
}{
\Gamma \vert \Sigma \vdash \lambda x : \sigma . e : \sigma \rightarrow \tau
}
\end{equation}</p>
<div class="src src-text">
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>of-lam : {t1:{x:tm}tm}{ty1:ty}{ty2:ty}
         {D:{x:tm}{D&#39;: of x ty1} of (t1 x) ty2}
         of (lam ty1 ([x] t1 x)) (arr ty1 ty2).</code></pre></div>
</div>
</li>
<li>
<p>TApp
\begin{equation}
\frac{
\Gamma \vert \Sigma \vdash e_{1} : \tau \rightarrow \tau^{\prime} \quad \Gamma \vert \Sigma \vdash e_2 : \tau
}{
\Gamma \vert \Sigma \vdash e_1 e_2 : \tau^{\prime}
}
\end{equation}</p>
<div class="src src-text">
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>of-app : {t1: tm}{t2:tm}{ty1: ty}{ty2:ty}
         {D1: of t1 (arr ty1 ty2)}
         {D2: of t2 ty1}
         of (app t1 t2) ty2.</code></pre></div>
</div>
</li>
<li>
<p>TCast
\begin{equation}
\frac{
\Gamma \vert \Sigma \vdash e : \sigma \quad \sigma \sim \tau
}{
\Gamma \vert \Sigma \vdash \langle \tau \rangle e : \tau
}
\end{equation}</p>
<div class="src src-text">
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>of-cast : {t1: tm}{ty1: ty}{ty2: ty}
          {D1: of t1 ty2}
          {D: consis ty1 ty2}
          of (cast ty2 t1) ty2.</code></pre></div>
</div>
</li>
</ul>
<p>In addition the the typing derivations listed in the paper, we have to add ones
for the new terms <code>empty</code> and <code>z</code> that we've derived.</p>
<ul>
<li>
<p>Empty
\begin{equation}
\frac{}
{
\Gamma \vert \Sigma \vdash \langle \rangle : ()
}
\end{equation}</p>
<div class="src src-text">
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>of-empty : of empty unit.</code></pre></div>
</div>
</li>
<li>
<p>z
\begin{equation}
\frac{}
{
\Gamma \vert \Sigma \vdash 0 : \mathbb{N}
}
\end{equation}</p>
<div class="src src-text">
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>of-z : of z nat.</code></pre></div>
</div>
</li>
</ul>
<div id=outline-container-headline-8 class=outline-3>
<h3 id=headline-8>
Context Lemmas & Type Equality
</h3>
<div id=outline-text-headline-8 class=outline-text-3>
<p>
To translate this into Adelfa, we need to account for abstraction capturing a
variable in the context. Adelfa addresses this problem through a context
schema. In this instance we define it as <code>Schema c := {T}(x: tm, y: of x T)</code>.</p>
<p>
We also don't have a built in way to determine type equality, we we'll define
one. It turns out, equality by reflexivity is sufficient for our needs.</p>
<div class="src src-text">
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>ty-eq : {ty1:ty}{ty2:ty} type.
ty-eq-refl : {ty1:ty} ty-eq ty1 ty1.</code></pre></div>
</div>
<p>
These are not relating directly to gradual typing, but are more properties of
any typing relation. Firstly, a type in a context is also a type not in a
context: \(\Gamma \vdash \tau \implies \varnothing \vdash \tau\).</p>
<div class="src src-text">
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>Theorem ty-independent : ctx G:c, forall T,
  {G |- T: ty} =&gt; {T: ty}.
induction on 1.
intros.
case H1. search. search. search.
apply IH to H2.
apply IH to H3. search.</code></pre></div>
</div>
<p>
Secondly, type equality also doesn't depend on a context: \(\Gamma \vdash \tau
= \tau^{\prime} \implies \varnothing \vdash \tau = \tau^{\prime}\).</p>
<div class="src src-text">
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>Theorem eq-independent : ctx G:c, forall t1 t2 D1,
  {G |- D1: ty-eq t1 t2} =&gt; {D1: ty-eq t1 t2}.
intros.
case H1.
apply ty-independent to H2.
search.</code></pre></div>
</div>
</div>
</div>
</div>
</div>
<div id=outline-container-headline-9 class=outline-2>
<h2 id=headline-9>
Type Uniqueness
</h2>
<div id=outline-text-headline-9 class=outline-text-2>
<p>
Let's look at Lemma 2.</p>
<p>
\begin{equation}
\Gamma \vert \Sigma \vdash e : \tau \land \Gamma \vert \Sigma \vdash e : \tau^{\prime} \implies \tau = \tau^{\prime}
\end{equation}</p>
<p>
We then translate this into Adelfa as such</p>
<div class="src src-text">
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>Theorem ty-uniq-lem : ctx G:c, forall E t1 t2 D1 D2,
  {G |- t1: ty} =&gt; {G |- t2: ty} =&gt;
  {G |- D1: of E t1} =&gt; {G |- D2: of E t2} =&gt;
  exists D3, {G |- D3: ty-eq t1 t2}.
induction on 3.
intros.
case H3.
case H4.
exists ty-eq-refl t2. search.
case H4.
apply IH to H7 H11 H8 H12.
case H13.
exists ty-eq-refl (arr ty1 t4). search.
case H4.
assert {G |- (arr ty1 t1): ty}. search.
assert {G |- (arr ty2 t2): ty}. search.
apply IH to H17 H18 H9 H15.
case H19.
exists ty-eq-refl t2. search.
case H4.
exists ty-eq-refl (t2 n n1). search.</code></pre></div>
</div>
<p>
Which is:</p>
<p>
\begin{equation}
\Gamma \vert \Sigma \vdash e : \tau \land \Gamma \vert \Sigma \vdash e : \tau^{\prime} \implies \Gamma \vert \Sigma \vdash \tau = \tau^{\prime}
\end{equation}</p>
<p>
So, to take the context off of the consequent, we only have to apply our
equality independent lemma.</p>
<div class="src src-text">
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>Theorem ty-uniq : ctx G:c, forall E T1 T2 D1 D2,
  {G |- T1: ty} =&gt; {G |- T2: ty} =&gt;
  {G |- D1: of E T1} =&gt; {G |- D2: of E T2} =&gt;
  exists D3, {D3: ty-eq T1 T2}.
intros.
apply ty-uniq-lem to H1 H2 H3 H4.
apply eq-independent to H5.
exists D3.
search.</code></pre></div>
</div>
</div>
</div>
<div id=outline-container-headline-10 class=outline-2>
<h2 id=headline-10>
Preservation
</h2>
<div id=outline-text-headline-10 class=outline-text-2>
<p>
Stated simply, "reduction preserves types" is the principle we want to prove. We
need a reduction strategy. The paper uses big step semantics, but I'll use small
step which will display the next step that a term will take. These steps will
occur until we reach a value. We define values to be:</p>
<ul>
<li>
<p>Lambdas: \(\lambda x : \tau . e\)</p>
</li>
<li>
<p>Casts: \(\langle \tau \rangle e\)</p>
</li>
<li>
<p>Empty: \(\langle \rangle\)</p>
</li>
<li>
<p>Zero: \(0\)</p>
</li>
</ul>
<div class="src src-text">
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>value : {t1: tm} type.
value-lam : {ty1: ty}{D: {x:tm} tm} value (lam ty1 ([x] D x)).
value-cast : {t1: tm}{ty1: ty} value (cast ty1 t1).
value-empty: value empty.
value-z : value z.</code></pre></div>
</div>
<p>
We then have to define how our program will actually execute through the lambda
terms. I'll use the single step notation of \(e \rightsquigarrow e^{\prime}\) to
denote that \(e\) reduces to \(e^{\prime}\) in a single step. We define a set of
reduction rules such that we know the exact reduction step the program will take
at any moment. For example, if we have two lambda terms \(e_1\) and \(e_2\)
being applied, \(e_1 \cdot e_2\), then we could reduce the left \(e_{1}
\rightsquigarrow e_1^{\prime}\) or the right \(e_{2} \rightsquigarrow
e_2^{\prime}\), or it could be the tricky case that \(e_1\) is of function type
\(\sigma_1\rightarrow\sigma_2\) and needs to be expanded into a lambda term. We
solve this issue by using the following order:</p>
<ol>
<li>
<p>Reduce the left side until it is a value.</p>
</li>
<li>
<p>Reduce the right side until it is a value.</p>
</li>
<li>
<p>If the left side has a cast, we can remove it.</p>
</li>
<li>
<p>Expand the left side into a lambda abstraction.</p>
</li>
</ol>
<p>These are captured in the following definitions:</p>
<div class="src src-text">
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>step : {t1: tm}{t2: tm} type.
step-app-1 : {E1: tm}{E2: tm}{E1&#39;: tm}{D: step E1 E1&#39;}
             step (app E1 E2) (app E1&#39; E2).
step-app-2 : {E1: tm}{E2: tm}{E2&#39;: tm}{D1: step E2 E2&#39;}
             {D2: value E1}
             step (app E1 E2) (app E1 E2&#39;).
step-app-beta : {E: {x:tm} tm}{T: ty}{E2:tm}{D1:value E2}
                step (app (lam T ([x] E x)) E2) (E E2).
step-app-cast: {E1: tm}{E2: tm}{ty1: ty}{ty2: ty}
                step (app (cast (arr ty1 ty2) E1) E2) (app E1 E2).</code></pre></div>
</div>
<p>
Which captures all \(t1 \rightsquigarrow t2\) relations. The precision in which
we defined <code>step</code> will come in handy when we move onto proving progress.</p>
<p>
Before we move onto preservation, let's prove a corollary that states values
cannot take any more steps.</p>
<div class="src src-text">
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>Theorem value-no-red : forall E V E&#39; D2,
 {V: value E} =&gt; {D2: step E E&#39;} =&gt; false.
intros.
case H1.
case H2.
case H2.
case H2.
case H2.</code></pre></div>
</div>
<p>
This isn't necessary for proving preservation, but is a nice way to confirm our
internal idea of what a <code>value</code> is. Looping back to preservation, we can prove
this without too much difficulty.</p>
<div class="src src-text">
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>Theorem preserv : forall E E&#39; T D1 D2,
  {D1: step E E&#39;} =&gt;
  {D2: of E T} =&gt;
  exists E, {E : of E&#39; T}.
induction on 1.
intros.
case H1.
case H2.
case H11.
inst H16 with n2 = E2.
inst H17 with n3 = D6.
exists D7 E2 D6. search.
case H2.
apply IH to H6 H13.
exists of-app E1 E2&#39; ty1 T D5 E. search.
case H2.
apply IH to H6 H11.
exists of-app E1&#39; E2 ty1 T E D4. search.</code></pre></div>
</div>
</div>
</div>
<div id=outline-container-headline-11 class=outline-2>
<h2 id=headline-11>
Progress
</h2>
<div id=outline-text-headline-11 class=outline-text-2>
<p>
Progress states that when we are evaluating a term, are able to either take a
step or we have reached a value. Progress and preservation together constitute
"type-safety" of a system. We've already defined values and steps we can take
within our language, so proving progress doesn't require too much more
information.</p>
<p>
The only new definitions we need are that of a <em>canonical</em> form. Well typed values
have to be in a canonical form. When we have reached a point where we have \(e_1
\cdot e_2\), we want to limit the forms of \(e_1\) to ones where \(e_1\) is a
cast \(\langle \tau_1 \rightarrow \tau_2 \rangle e_1\) or of function type, and
can be expanded into a lambda \(e_1 : \tau_1 \rightarrow \tau_2 \Rightarrow
(\lambda x : \tau_1 . e_1^{\prime}) : \tau_2\). Any other form for \(e_1\) would
not lead to a well typed term. We want to list all canonical forms:</p>
<div class="src src-text">
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>canonical : {t1 : tm} {ty1: ty} type.
canonical-lam : {t1: {x:tm} tm} {ty1: ty} {ty2: ty}
                canonical (lam ty1 ([x] t1 x)) (arr ty1 ty2).
canonical-empty : canonical empty unit.
canonical-z : canonical z nat.
canonical-cast : {t1: tm} {ty1 : ty}
                 canonical (cast ty1 t1) ty1.</code></pre></div>
</div>
<p>
And formulate a theorem about well typed values being canonical:</p>
<div class="src src-text">
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>Theorem canonical : forall E T D1 D2,
  {D1: of E T} =&gt;
  {D2: value E} =&gt; exists D3, {D3: canonical E T}.
intros.
case H1.
exists canonical-z. search.
exists canonical-empty. search.
case H2.
exists canonical-cast t1 T. search.
exists canonical-lam t1 ty1 ty2. search.
case H2.</code></pre></div>
</div>
<p>
We're now able to prove progress.</p>
<div class="src src-text">
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>Theorem progress : forall E D1 ty1,
  {E: tm} =&gt; {D1: of E ty1} =&gt;
  (exists E&#39; D2, {D2: step E E&#39;} /\ {E&#39; : tm}) \/ (exists D3, {D3: value E}).
induction on 1.
intros.
case H1.
right.
exists value-z. search.
right.
exists value-empty. search.
case H2.
right.
exists value-cast t1 ty2. search.
case H2.
apply IH to H3 H9. case H11. case H11.
left.
exists app E&#39; t2.
exists step-app-1 t1 t2 E&#39; D1.
split. search. search.
apply IH to H4 H10. case H12. case H12.
left.
exists app t1 E&#39;.
exists step-app-2 t1 t2 E&#39; D4 D1.
split. search. search.
left.
apply canonical to H9 H11. case H13. case H9.
exists app t3 t2.
exists step-app-cast t3 t2 ty2 ty1. split. search. search.
inst H14 with n = t2.
exists t3 t2.
exists step-app-beta t3 ty2 t2 D4. split. search. search.
right.
exists value-lam ty2 D.
search.</code></pre></div>
</div>
</div>
</div>
</div>
</article>
<div id=footer-post-container>
<div id=footer-post>
<div id=nav-footer style=display:none>
<ul>
<li><a href=/>Home</a></li>
<li><a href=/posts>All Posts</a></li>
<li><a href=/about>About</a></li>
</ul>
</div>
<div id=share-footer style=display:none>
<ul>
<li>
<a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fchasejohnson.tech%2fposts%2fgradual-typing-adelfa%2f" aria-label=Facebook>
<i class="fab fa-facebook fa-lg" aria-hidden=true></i>
</a>
</li>
<li>
<a class=icon href="https://twitter.com/share?url=https%3a%2f%2fchasejohnson.tech%2fposts%2fgradual-typing-adelfa%2f&text=Gradual%20Typing%20in%20Adelfa" aria-label=Twitter>
<i class="fab fa-twitter fa-lg" aria-hidden=true></i>
</a>
</li>
<li>
<a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fchasejohnson.tech%2fposts%2fgradual-typing-adelfa%2f&title=Gradual%20Typing%20in%20Adelfa" aria-label=Linkedin>
<i class="fab fa-linkedin fa-lg" aria-hidden=true></i>
</a>
</li>
<li>
<a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fchasejohnson.tech%2fposts%2fgradual-typing-adelfa%2f&is_video=false&description=Gradual%20Typing%20in%20Adelfa" aria-label=Pinterest>
<i class="fab fa-pinterest fa-lg" aria-hidden=true></i>
</a>
</li>
<li>
<a class=icon href="mailto:?subject=Gradual%20Typing%20in%20Adelfa&body=Check out this article: https%3a%2f%2fchasejohnson.tech%2fposts%2fgradual-typing-adelfa%2f" aria-label=Email>
<i class="fas fa-envelope fa-lg" aria-hidden=true></i>
</a>
</li>
<li>
<a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fchasejohnson.tech%2fposts%2fgradual-typing-adelfa%2f&title=Gradual%20Typing%20in%20Adelfa" aria-label=Pocket>
<i class="fab fa-get-pocket fa-lg" aria-hidden=true></i>
</a>
</li>
<li>
<a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fchasejohnson.tech%2fposts%2fgradual-typing-adelfa%2f&title=Gradual%20Typing%20in%20Adelfa" aria-label=reddit>
<i class="fab fa-reddit fa-lg" aria-hidden=true></i>
</a>
</li>
<li>
<a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fchasejohnson.tech%2fposts%2fgradual-typing-adelfa%2f&name=Gradual%20Typing%20in%20Adelfa&description=Introduction%20%20%20Gradual%20Typing%20is%20a%20type%20system%20that%20marries%20static%20and%20dynamic%20typing.%20It%20was%20developed%20in%202006%20by%20Jeremy%20Siek%20and%20Walid%20Taha.%20Dynamic%20type%20systems%20offer%20complete%20flexibility%20and%20agility%3b%20whereas%20static%20typing%20offers%20type-related%20error%20detection%20earlier.%20Gradual%20typing%20allows%20us%20to%20declare%20types%20as%20dynamic%20and%20also%20specify%20types.%20Moreover%2c%20we%20can%20coerce%20types%20to%20and%20from%20dynamic%20throughout%20its%20execution.%0a%20I%20won%26%2339%3bt%20be%20going%20over%20Gradual%20Typing%20too%20closely%2c%20because%20Professor%20Siek%20has%20his%20very%20own%20excellent%20blog%20you%20should%20give%20a%20read%20if%20you%26%2339%3bre%20interested." aria-label=Tumblr>
<i class="fab fa-tumblr fa-lg" aria-hidden=true></i>
</a>
</li>
<li>
<a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fchasejohnson.tech%2fposts%2fgradual-typing-adelfa%2f&t=Gradual%20Typing%20in%20Adelfa" aria-label="Hacker News">
<i class="fab fa-hacker-news fa-lg" aria-hidden=true></i>
</a>
</li>
</ul>
</div>
<div id=actions-footer>
<a id=menu-toggle class=icon href=# onclick="return $('#nav-footer').toggle(),!1" aria-label=Menu>
<i class="fas fa-bars fa-lg" aria-hidden=true></i> Menu</a>
<a id=share-toggle class=icon href=# onclick="return $('#share-footer').toggle(),!1" aria-label=Share>
<i class="fas fa-share-alt fa-lg" aria-hidden=true></i> share</a>
<a id=top style=display:none class=icon href=# onclick="$('html, body').animate({scrollTop:0},'fast')" aria-label="Top of Page">
<i class="fas fa-chevron-up fa-lg" aria-hidden=true></i> Top</a>
</div>
</div>
</div>
<footer id=footer>
<div class=footer-left>
Copyright &copy; 2022 Chase Johnson
</div>
<div class=footer-right>
<nav>
<ul>
<li><a href=/>Home</a></li>
<li><a href=/posts>All Posts</a></li>
<li><a href=/about>About</a></li>
</ul>
</nav>
</div>
</footer>
</div>
</body>
<link rel=stylesheet href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
<script src=/js/code-copy.js></script>
<script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}}</script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>
</html>